package chess

import (
	"math"
	"std"
	"time"

	"gno.land/p/demo/avl"
)

type lobbyPlayer struct {
	joinedAt time.Time
	player   *Player
	lo, hi   float64
}

func (l lobbyPlayer) r(cat Category) float64 { return l.player.CategoryInfo[cat].Rating }

// time control lobby divisions. N+M -> tcLobbyNpM
const (
	tcLobby5p0 = iota
	tcLobby10p5
	tcLobbyMax
)

func tcCategory(tc int) Category {
	switch tc {
	case tcLobby5p0:
		return Blitz
	default:
		return Rapid
	}
}

var (
	lobby          [tcLobbyMax][]lobbyPlayer
	lobbyUpdatedAt [tcLobbyMax]time.Time
	playerGameID   avl.Tree // player addr -> game id (string). only set when not in lobby.
)

func LobbyJoin(seconds, increment int) {
	std.AssertOriginCall()

	var tcLobby int
	switch {
	case seconds == (60*5) && increment == 0:
		tcLobby = tcLobby5p0
	case seconds == (60*10) && increment == 5:
		tcLobby = tcLobby10p5
	default:
		panic("can only use time controls 5+0 or 10+5")
	}

	caller := std.GetOrigCaller()
	for i := 0; i < tcLobbyMax; i++ {
		for _, pl := range lobby[i] {
			if pl.player.Address == caller {
				panic("you are already in the lobby")
			}
		}
	}
	// TODO: Check if has open games

	// remove caller from playerGameID, so LobbyGameFound
	// returns the right value.
	playerGameID.Remove(caller.String())

	lobby[tcLobby] = append(lobby[tcLobby], lobbyPlayer{joinedAt: time.Now(), player: getPlayer(caller)})
	refreshLobby(tcLobby)
}

// refreshLobby serves to run through the lobby, update lo/hi values and find if there are
// any matchings to be made with the current user.
func refreshLobby(tc int) {
	// determine sub lobby
	sublob := lobby[tc]
	now := time.Now()
	cat := tcCategory(tc)

	// check if time passed; if so update leaderboard lo/hi's.
	// check if we have someone "timed out" and match them to the closest
	// player available in the lobby.
	// (we don't iteratively match all users because we are still presumably running
	// using someone's gas).
	if !lobbyUpdatedAt[tc].Equal(now) {
		firstTimeout := -1
		for pos, player := range sublob {
			rat := player.r(cat)
			wait := now.Sub(player.joinedAt) / time.Second
			if wait >= 20 {
				if firstTimeout < 0 {
					firstTimeout = pos
				}
				player.lo, player.hi = math.Inf(-1), math.Inf(1)
			} else {
				halfsize := bracketSize[int(wait)] / 2
				player.lo, player.hi = rat-halfsize, rat+halfsize
			}
			sublob[pos] = player
		}
		lobbyUpdatedAt[tc] = now

		if firstTimeout >= 0 && len(sublob) >= 2 {
			ftr := sublob[firstTimeout].r(cat)
			pos := lobbyClosest(sublob, cat, ftr, firstTimeout)
			lobbyMatch(tc, firstTimeout, pos)
		}
	}

	if len(sublob) < 2 {
		// 1 or 0 players; not much we can do!
		return
	}

	callerAddr := std.GetOrigCaller()
	callerPos := -1
	var caller lobbyPlayer
	for idx, player := range sublob {
		if player.player.Address == callerAddr {
			callerPos = idx
			caller = player
			break
		}
	}
	if callerPos < 0 {
		// perform nothing, player not found
		return
	}
	closestPos := lobbyClosest(sublob, cat, caller.r(cat), callerPos)
	closest := sublob[closestPos]

	// ensure each is the other's bracket,
	// OR one of them has been waiting 20s+
	if now.Sub(caller.joinedAt) >= time.Second*20 ||
		now.Sub(closest.joinedAt) >= time.Second*20 ||
		(closest.r(cat) >= caller.lo && closest.r(cat) <= caller.hi &&
			caller.r(cat) >= closest.lo && caller.r(cat) <= closest.hi) {
		lobbyMatch(tc, callerPos, closestPos)
	}
}

func lobbyClosest(sublob []lobbyPlayer, cat Category, rating float64, skip int) (idx int) {
	delta := math.Inf(1)
	for i, pl := range sublob {
		if i == skip {
			continue
		}
		if cd := math.Abs(rating - pl.r(cat)); cd < delta {
			delta, idx = cd, i
		}
	}
	return
}

func lobbyMatch(tc, p1, p2 int) {
	// Get the two players, create a new game with them.
	var secs, incr int
	switch tc {
	case tcLobby5p0:
		secs, incr = 60*5, 0
	case tcLobby10p5:
		secs, incr = 60*10, 5
	}
	a1, a2 := lobby[tc][p1].player.Address, lobby[tc][p2].player.Address
	game := newGame(a1, a2, secs, incr)

	// remove p1 and p2 from lobby
	if p1 > p2 {
		p1, p2 = p2, p1
	}
	nl := append(lobby[tc][:p1], lobby[tc][p1+1:p2]...)
	nl = append(nl, lobby[tc][p2+1:]...)
	lobby[tc] = nl

	// add to playerGameID
	playerGameID.Set(a1.String(), game.ID)
	playerGameID.Set(a2.String(), game.ID)
}

/*
generated by python code:

	for i in range(0,21):
		print(i**(2.889223691)+50, ",")

rationale: give brackets in an exponential range between
50 and 5000, dividing it into 20 steps.
"magic constant" obtained solving for in c in the equation:

	5000=x^c+50 (when x = 19)

which comes out to be ln(delta)/ln(steps), delta = 5000-50, steps = 19.
*/
var bracketSize = [...]float64{
	50.0,
	51.0,
	57.40871681853337,
	73.9061716023745,
	104.88908489721928,
	154.58772007078807,
	227.1140556172569,
	326.48863117463014,
	456.65768643193456,
	621.5050406821772,
	824.8608007005079,
	1070.508009380841,
	1362.1878826502266,
	1703.6040371462038,
	2098.425971916753,
	2550.291983513367,
	3062.811640854144,
	3639.567911426751,
	4284.119006778646,
	5000,
}

func LobbyGameFound() string {
	refreshLobby(tcLobby5p0)
	refreshLobby(tcLobby10p5)

	val, ok := playerGameID.Get(std.GetOrigCaller().String())
	if !ok {
		return "null"
	}
	return GetGame(val.(string))
}

func LobbyQuit() {
	caller := std.GetOrigCaller()
	for tc, sublob := range lobby {
		for i, pl := range sublob {
			if pl.player.Address == caller {
				lobby[tc] = append(sublob[:i], sublob[i:]...)
				return
			}
		}
	}

	panic("not found")
}
